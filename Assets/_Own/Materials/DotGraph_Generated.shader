Shader "Custom/Dot"
{
    Properties
    {
        [NoScaleOffset] Texture2D_3F810299("Base Texture", 2D) = "white" {}
Vector1_324C3AD2("Alpha Clipping Threshold", Range(0, 1)) = 0.1
[HDR]Color_296807D0("Emission", Color) = (1,1,1,0)
Vector1_A1B84C3E("Falloff Multiplier", Range(0, 10)) = 1
Vector1_ADA3E76E("Min Falloff Distance", Range(0, 15)) = 0

    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="LightweightPipeline"
            "RenderType"="Transparent"
            "Queue"="Transparent+0"
        }
        Pass
        {
            Name "StandardUnlit"
            Tags{"LightMode" = "LightweightForward"}

            // Material options generated by graph

            Blend One One

            Cull Back

            ZTest Always

            ZWrite Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            // -------------------------------------
            // Lightweight Pipeline keywords
            #pragma shader_feature _SAMPLE_GI

            // -------------------------------------
            // Unity defined keywords
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile_fog

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing
            
            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph
            #define _AlphaClip 1

            // Lighting include is needed because of GI
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/Shaders/UnlitInput.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float Vector1_324C3AD2;
            float4 Color_296807D0;
            float Vector1_A1B84C3E;
            float Vector1_ADA3E76E;
            CBUFFER_END

            TEXTURE2D(Texture2D_3F810299); SAMPLER(samplerTexture2D_3F810299); float4 Texture2D_3F810299_TexelSize;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 ViewSpacePosition;
                half4 uv0;
            };


            void Unity_Length_float3(float3 In, out float Out)
            {
                Out = length(In);
            }

            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Maximum_float(float A, float B, out float Out)
            {
                Out = max(A, B);
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_Divide_float(float A, float B, out float Out)
            {
                Out = A / B;
            }

            void Unity_Clamp_float(float In, float Min, float Max, out float Out)
            {
                Out = clamp(In, Min, Max);
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_ColorspaceConversion_HSV_RGB_float(float3 In, out float3 Out)
            {
                float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 P = abs(frac(In.xxx + K.xyz) * 6.0 - K.www);
                Out = In.z * lerp(K.xxx, saturate(P - K.xxx), In.y);
            }

            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Color;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float _Length_38C506F0_Out;
                Unity_Length_float3(IN.ViewSpacePosition, _Length_38C506F0_Out);
                float _Property_2EC7C888_Out = Vector1_ADA3E76E;
                float _Subtract_4E8D09D0_Out;
                Unity_Subtract_float(_Length_38C506F0_Out, _Property_2EC7C888_Out, _Subtract_4E8D09D0_Out);
                float _Maximum_8B83FBC0_Out;
                Unity_Maximum_float(_Subtract_4E8D09D0_Out, 0, _Maximum_8B83FBC0_Out);
                float _Multiply_8257CEE7_Out;
                Unity_Multiply_float(_Maximum_8B83FBC0_Out, _Maximum_8B83FBC0_Out, _Multiply_8257CEE7_Out);

                float _Property_F4FBDF53_Out = Vector1_A1B84C3E;
                float _Multiply_88D93AF6_Out;
                Unity_Multiply_float(_Multiply_8257CEE7_Out, _Property_F4FBDF53_Out, _Multiply_88D93AF6_Out);

                float _Add_803D74C4_Out;
                Unity_Add_float(_Multiply_88D93AF6_Out, 1, _Add_803D74C4_Out);
                float _Divide_E99BDECB_Out;
                Unity_Divide_float(1, _Add_803D74C4_Out, _Divide_E99BDECB_Out);
                float _Clamp_704E249_Out;
                Unity_Clamp_float(_Divide_E99BDECB_Out, 0, 1, _Clamp_704E249_Out);
                float _OneMinus_F0841AD_Out;
                Unity_OneMinus_float(_Clamp_704E249_Out, _OneMinus_F0841AD_Out);
                float _Multiply_E6658460_Out;
                Unity_Multiply_float(_OneMinus_F0841AD_Out, 0.5, _Multiply_E6658460_Out);

                float3 _Vector3_9720648F_Out = float3(_Multiply_E6658460_Out,1,1);
                float3 _ColorspaceConversion_EC19C6C4_Out;
                Unity_ColorspaceConversion_HSV_RGB_float(_Vector3_9720648F_Out, _ColorspaceConversion_EC19C6C4_Out);
                float4 _UV_135E4AC0_Out = IN.uv0;
                float4 _SampleTexture2D_E713EA74_RGBA = SAMPLE_TEXTURE2D(Texture2D_3F810299, samplerTexture2D_3F810299, (_UV_135E4AC0_Out.xy));
                float _SampleTexture2D_E713EA74_R = _SampleTexture2D_E713EA74_RGBA.r;
                float _SampleTexture2D_E713EA74_G = _SampleTexture2D_E713EA74_RGBA.g;
                float _SampleTexture2D_E713EA74_B = _SampleTexture2D_E713EA74_RGBA.b;
                float _SampleTexture2D_E713EA74_A = _SampleTexture2D_E713EA74_RGBA.a;
                float _Split_7535A2B5_R = _SampleTexture2D_E713EA74_RGBA[0];
                float _Split_7535A2B5_G = _SampleTexture2D_E713EA74_RGBA[1];
                float _Split_7535A2B5_B = _SampleTexture2D_E713EA74_RGBA[2];
                float _Split_7535A2B5_A = _SampleTexture2D_E713EA74_RGBA[3];
                float4 _Combine_2F736A03_RGBA;
                float3 _Combine_2F736A03_RGB;
                float2 _Combine_2F736A03_RG;
                Unity_Combine_float(_Split_7535A2B5_R, _Split_7535A2B5_G, _Split_7535A2B5_B, 0, _Combine_2F736A03_RGBA, _Combine_2F736A03_RGB, _Combine_2F736A03_RG);
                float4 _Property_B6F8D27A_Out = Color_296807D0;
                float3 _Add_29951D0A_Out;
                Unity_Add_float3(_Combine_2F736A03_RGB, (_Property_B6F8D27A_Out.xyz), _Add_29951D0A_Out);
                float3 _Multiply_E9B250E3_Out;
                Unity_Multiply_float(_ColorspaceConversion_EC19C6C4_Out, _Add_29951D0A_Out, _Multiply_E9B250E3_Out);

                float3 _Multiply_C4824BBA_Out;
                Unity_Multiply_float((_Clamp_704E249_Out.xxx), _Multiply_E9B250E3_Out, _Multiply_C4824BBA_Out);

                float _Property_C9327209_Out = Vector1_324C3AD2;
                surface.Color = _Multiply_C4824BBA_Out;
                surface.Alpha = _Split_7535A2B5_A;
                surface.AlphaClipThreshold = _Property_C9327209_Out;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct GraphVertexOutput
            {
                float4 position : POSITION;

                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            GraphVertexOutput vert (GraphVertexInput v)
            {
                GraphVertexOutput o = (GraphVertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

                VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

                VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                o.position = TransformObjectToHClip(v.vertex.xyz);
                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

                return o;
            }

            half4 frag (GraphVertexOutput IN ) : SV_Target
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;
                float3 ViewSpacePosition = mul(UNITY_MATRIX_V,float4(WorldSpacePosition,1.0)).xyz;

                
                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;
                // Surface description inputs defined by graph
                surfaceInput.ViewSpacePosition = ViewSpacePosition;
                surfaceInput.uv0 = uv0;


                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);
                float3 Color = float3(0.5, 0.5, 0.5);
                float Alpha = 1;
                float AlphaClipThreshold = 0;
                // Surface description remap performed by graph
                Color = surf.Color;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

                
         #if _AlphaClip
                clip(Alpha - AlphaClipThreshold);
        #endif
        #ifdef _ALPHAPREMULTIPLY_ON
                
                Color *= Alpha;
        #endif
                return half4(Color, Alpha);
            }
            ENDHLSL
        }
        Pass
        {
            Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On ZTest LEqual

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            // Defines generated by graph
            #define _AlphaClip 1

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float Vector1_324C3AD2;
            float4 Color_296807D0;
            float Vector1_A1B84C3E;
            float Vector1_ADA3E76E;
            CBUFFER_END

            TEXTURE2D(Texture2D_3F810299); SAMPLER(samplerTexture2D_3F810299); float4 Texture2D_3F810299_TexelSize;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                half4 uv0;
            };


            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float4 _UV_135E4AC0_Out = IN.uv0;
                float4 _SampleTexture2D_E713EA74_RGBA = SAMPLE_TEXTURE2D(Texture2D_3F810299, samplerTexture2D_3F810299, (_UV_135E4AC0_Out.xy));
                float _SampleTexture2D_E713EA74_R = _SampleTexture2D_E713EA74_RGBA.r;
                float _SampleTexture2D_E713EA74_G = _SampleTexture2D_E713EA74_RGBA.g;
                float _SampleTexture2D_E713EA74_B = _SampleTexture2D_E713EA74_RGBA.b;
                float _SampleTexture2D_E713EA74_A = _SampleTexture2D_E713EA74_RGBA.a;
                float _Split_7535A2B5_R = _SampleTexture2D_E713EA74_RGBA[0];
                float _Split_7535A2B5_G = _SampleTexture2D_E713EA74_RGBA[1];
                float _Split_7535A2B5_B = _SampleTexture2D_E713EA74_RGBA[2];
                float _Split_7535A2B5_A = _SampleTexture2D_E713EA74_RGBA[3];
                float _Property_C9327209_Out = Vector1_324C3AD2;
                surface.Alpha = _Split_7535A2B5_A;
                surface.AlphaClipThreshold = _Property_C9327209_Out;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            float3 _LightDirection;

            VertexOutput ShadowPassVertex(GraphVertexInput v)
            {
                VertexOutput o;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

                VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

                VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

                
                float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
                float3 normalWS = TransformObjectToWorldNormal(v.normal);

                float4 clipPos = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

            #if UNITY_REVERSED_Z
                clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
            #else
                clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
            #endif
                o.clipPos = clipPos;

                return o;
            }

            half4 ShadowPassFragment(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }

            ENDHLSL
        }

        Pass
        {
            Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph
            #define _AlphaClip 1

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float Vector1_324C3AD2;
            float4 Color_296807D0;
            float Vector1_A1B84C3E;
            float Vector1_ADA3E76E;
            CBUFFER_END

            TEXTURE2D(Texture2D_3F810299); SAMPLER(samplerTexture2D_3F810299); float4 Texture2D_3F810299_TexelSize;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                half4 uv0;
            };


            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float4 _UV_135E4AC0_Out = IN.uv0;
                float4 _SampleTexture2D_E713EA74_RGBA = SAMPLE_TEXTURE2D(Texture2D_3F810299, samplerTexture2D_3F810299, (_UV_135E4AC0_Out.xy));
                float _SampleTexture2D_E713EA74_R = _SampleTexture2D_E713EA74_RGBA.r;
                float _SampleTexture2D_E713EA74_G = _SampleTexture2D_E713EA74_RGBA.g;
                float _SampleTexture2D_E713EA74_B = _SampleTexture2D_E713EA74_RGBA.b;
                float _SampleTexture2D_E713EA74_A = _SampleTexture2D_E713EA74_RGBA.a;
                float _Split_7535A2B5_R = _SampleTexture2D_E713EA74_RGBA[0];
                float _Split_7535A2B5_G = _SampleTexture2D_E713EA74_RGBA[1];
                float _Split_7535A2B5_B = _SampleTexture2D_E713EA74_RGBA[2];
                float _Split_7535A2B5_A = _SampleTexture2D_E713EA74_RGBA[3];
                float _Property_C9327209_Out = Vector1_324C3AD2;
                surface.Alpha = _Split_7535A2B5_A;
                surface.AlphaClipThreshold = _Property_C9327209_Out;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

                VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

                VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

                o.clipPos = TransformObjectToHClip(v.vertex.xyz);
                return o;
            }

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }
            ENDHLSL
        }
    }
    FallBack "Hidden/InternalErrorShader"
}
